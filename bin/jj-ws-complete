#!/usr/bin/env bash
#
# jj-ws-complete - Complete work in a workspace and clean up
#
# Usage: jj-ws-complete [<workspace-name>] [options]
#        jj-ws-complete --all [options]
#
# This script is designed for AI agents to:
# 1. Create a ws/<workspace-name> bookmark for the completed work
# 2. Merge the work to main (locally, not pushed)
# 3. Close the associated bead task
# 4. Clean up workspace directory
#
# The bookmark allows:
# - Listing completed work: jj bookmark list -r 'bookmarks(glob:"ws/*")'
# - Selective pushing: jj git push -b ws/<name>
# - Review before merging to main
#
# Exit codes:
#   0 - Success
#   1 - Invalid arguments
#   2 - Not in a jj workspace
#   3 - In default workspace (nothing to complete)
#   4 - Workspace not found

set -euo pipefail

# ─────────────────────────────────────────────────────────────────
# Concurrency safety: Acquire lock before modifying jj state
# ─────────────────────────────────────────────────────────────────
# Multiple agents may run simultaneously. Use mkdir-based locking
# (atomic on POSIX) to serialize jj operations and prevent races.

LOCK_DIR=""

acquire_lock() {
    local repo_root="$1"
    LOCK_DIR="$repo_root/.jj/workspace-ops.lock"
    local timeout=30
    local waited=0

    # mkdir is atomic - will fail if directory exists
    while ! mkdir "$LOCK_DIR" 2>/dev/null; do
        if [[ $waited -ge $timeout ]]; then
            echo "Error: Timed out waiting for workspace lock" >&2
            echo "Another agent may be performing workspace operations" >&2
            echo "If stuck, remove: $LOCK_DIR" >&2
            exit 1
        fi
        sleep 1
        ((waited++))
    done

    # Set trap to release lock on exit (normal or error)
    trap release_lock EXIT
}

release_lock() {
    if [[ -n "$LOCK_DIR" && -d "$LOCK_DIR" ]]; then
        rmdir "$LOCK_DIR" 2>/dev/null || true
    fi
}

# ─────────────────────────────────────────────────────────────────
# Argument parsing
# ─────────────────────────────────────────────────────────────────

TARGET_WS=""
COMPLETE_ALL=false
NO_MERGE=false
NO_CLEANUP=false
DO_REBASE=false
JSON_OUTPUT=false
CLOSE_REASON=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--all)
            COMPLETE_ALL=true
            shift
            ;;
        -r|--rebase)
            DO_REBASE=true
            shift
            ;;
        --no-merge)
            NO_MERGE=true
            shift
            ;;
        --no-cleanup)
            NO_CLEANUP=true
            shift
            ;;
        --reason)
            CLOSE_REASON="$2"
            shift 2
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        -h|--help)
            cat <<'EOF'
Usage: jj-ws-complete [<workspace-name>] [options]
       jj-ws-complete --all [options]

Complete work in a workspace, merge to main, and clean up.

Arguments:
  <workspace-name>   Specific workspace to complete (default: current workspace)

Options:
  -a, --all        Complete ALL workspaces
  -r, --rebase     Rebase parallel branches onto main before merging
  --no-merge       Don't merge work to main (just create bookmark)
  --no-cleanup     Don't remove workspace after completion
  --reason <text>  Reason for closing bead task
  --json           Output result as JSON
  -h, --help       Show this help

Examples:
  jj-ws-complete                     # Complete current workspace
  jj-ws-complete hs-memory-leaks     # Complete specific workspace
  jj-ws-complete --all               # Complete all workspaces
  jj-ws-complete -r hs-memory-leaks  # Complete with rebase if parallel
EOF
            exit 0
            ;;
        -*)
            echo "Error: Unknown option $1" >&2
            exit 1
            ;;
        *)
            if [[ -z "$TARGET_WS" ]]; then
                TARGET_WS="$1"
            else
                echo "Error: Unexpected argument $1" >&2
                exit 1
            fi
            shift
            ;;
    esac
done

# ─────────────────────────────────────────────────────────────────
# Repository detection
# ─────────────────────────────────────────────────────────────────

WS_PATH=$(jj workspace root 2>/dev/null || true)
if [[ -z "$WS_PATH" ]]; then
    echo "Error: Not in a jj repository" >&2
    exit 2
fi

# Find repo root (whether in workspace or default)
if [[ "$WS_PATH" == *"/.workspaces/"* ]]; then
    REPO_ROOT=$(dirname "$(dirname "$WS_PATH")")
else
    REPO_ROOT="$WS_PATH"
fi

PROJECT_NAME=$(basename "$REPO_ROOT")

# Acquire lock for concurrent safety
acquire_lock "$REPO_ROOT"

# ─────────────────────────────────────────────────────────────────
# Determine which workspace(s) to complete
# ─────────────────────────────────────────────────────────────────

get_all_workspaces() {
    jj workspace list 2>/dev/null | grep -v '^default:' | awk -F: '{print $1}' || true
}

if $COMPLETE_ALL; then
    # Complete all non-default workspaces
    WORKSPACES=$(get_all_workspaces)
    if [[ -z "$WORKSPACES" ]]; then
        echo "No workspaces to complete (only default exists)" >&2
        exit 0
    fi
    # Process each workspace - for now just do the first, TODO: loop
    # For --all, we'll need to refactor into a function
    echo "Error: --all not yet implemented. Complete workspaces individually." >&2
    exit 1
elif [[ -n "$TARGET_WS" ]]; then
    # Specific workspace requested
    CURRENT_WS="$TARGET_WS"
    WS_DIR="$REPO_ROOT/.workspaces/$CURRENT_WS"
    if [[ ! -d "$WS_DIR" ]]; then
        echo "Error: Workspace '$TARGET_WS' not found at $WS_DIR" >&2
        exit 4
    fi
    # Change to workspace directory so jj commands work on that workspace
    cd "$WS_DIR"
else
    # Use current workspace
    if [[ "$WS_PATH" == *"/.workspaces/"* ]]; then
        CURRENT_WS=$(basename "$WS_PATH")
    else
        echo "Error: In default workspace - nothing to complete" >&2
        echo "Specify a workspace name or use --all" >&2
        exit 3
    fi
    WS_DIR="$REPO_ROOT/.workspaces/$CURRENT_WS"
fi

# ─────────────────────────────────────────────────────────────────
# Check for work to complete
# ─────────────────────────────────────────────────────────────────

# Get current commit info
COMMIT_DESC=$(jj log -r @ --no-graph -T 'description' 2>/dev/null || true)
COMMIT_EMPTY=$(jj log -r @ --no-graph -T 'if(empty, "true", "false")' 2>/dev/null || echo "true")
CHANGE_ID=$(jj log -r @ --no-graph -T 'change_id.short(12)' 2>/dev/null || true)

if [[ "$COMMIT_EMPTY" == "true" && -z "$COMMIT_DESC" ]]; then
    echo "Warning: Current commit is empty with no description" >&2
    echo "Consider using 'jj describe' to document your work first" >&2
fi

# ─────────────────────────────────────────────────────────────────
# Create workspace bookmark for tracking completed work
# ─────────────────────────────────────────────────────────────────
# Creates ws/<workspace-name> bookmark so completed work can be:
# - Listed: jj bookmark list -r 'bookmarks(glob:"ws/*")'
# - Selectively pushed: jj git push -b ws/<name>
# - Reviewed before merging to main

BOOKMARK_NAME="ws/$CURRENT_WS"
BOOKMARK_CREATED=false

if [[ -n "$CHANGE_ID" ]]; then
    # Create or move bookmark to current change
    if jj bookmark set "$BOOKMARK_NAME" -r @ 2>/dev/null; then
        BOOKMARK_CREATED=true
        echo "Created bookmark '$BOOKMARK_NAME' at $CHANGE_ID" >&2
    else
        echo "Warning: Failed to create bookmark '$BOOKMARK_NAME'" >&2
    fi
fi

# ─────────────────────────────────────────────────────────────────
# Close bead task (with bookmark reference)
# ─────────────────────────────────────────────────────────────────

TASK_CLOSED=false
TASK_ID=""

if command -v bd &>/dev/null; then
    # Try to find task matching workspace name
    TASK_ID="$PROJECT_NAME-$CURRENT_WS"
    if ! bd show "$TASK_ID" &>/dev/null; then
        # Try without project prefix
        if bd show "$CURRENT_WS" &>/dev/null; then
            TASK_ID="$CURRENT_WS"
        else
            TASK_ID=""
        fi
    fi

    if [[ -n "$TASK_ID" ]]; then
        # Add comment with bookmark reference for traceability
        if $BOOKMARK_CREATED; then
            bd comments add "$TASK_ID" "Completed in jj workspace. Bookmark: $BOOKMARK_NAME (change: $CHANGE_ID)" 2>/dev/null || true
        fi

        # Build close reason with bookmark info
        if [[ -n "$CLOSE_REASON" ]]; then
            FULL_REASON="$CLOSE_REASON"
        else
            FULL_REASON="Completed in workspace $CURRENT_WS"
        fi

        if $BOOKMARK_CREATED; then
            FULL_REASON="$FULL_REASON [bookmark: $BOOKMARK_NAME]"
        fi

        if bd close "$TASK_ID" -r "$FULL_REASON" 2>/dev/null; then
            TASK_CLOSED=true
        fi
    fi
fi

# ─────────────────────────────────────────────────────────────────
# Merge work to main (moves main bookmark to current commit)
# ─────────────────────────────────────────────────────────────────
# This makes the workspace work part of main locally.
# Does NOT push to GitHub - that still requires explicit consent.
# Use --no-merge to skip this and just create the bookmark.
# Use --rebase / -r to rebase parallel branches onto main first.

MERGED=false
REBASED=false
PREV_MAIN=""
if ! $NO_MERGE; then
    # Record previous main position for output
    PREV_MAIN=$(jj log -r main --no-graph -T 'change_id.short(8)' 2>/dev/null || echo "")

    # Check if @ is a descendant of main (main is an ancestor of @)
    IS_DESCENDANT=false
    if jj log -r '@ & descendants(main)' --no-graph -T 'x' 2>/dev/null | grep -q 'x'; then
        IS_DESCENDANT=true
    fi

    # If parallel branch and --rebase requested, rebase onto main first
    if ! $IS_DESCENDANT && $DO_REBASE; then
        echo "Rebasing onto main (parallel branch detected)..." >&2
        if jj rebase -r @ -d main 2>/dev/null; then
            REBASED=true
            CHANGE_ID=$(jj log -r @ --no-graph -T 'change_id.short(12)' 2>/dev/null || echo "$CHANGE_ID")
        else
            echo "Warning: Failed to rebase onto main" >&2
        fi
    fi

    # Move main bookmark to current commit
    if jj bookmark set main -r @ 2>/dev/null; then
        MERGED=true
        if $REBASED; then
            echo "Rebased and merged to main: $PREV_MAIN → $CHANGE_ID" >&2
        else
            echo "Merged to main: $PREV_MAIN → $CHANGE_ID" >&2
        fi
    else
        if ! $IS_DESCENDANT && ! $DO_REBASE; then
            echo "Warning: Parallel branch - use --rebase to merge, or merge manually" >&2
        else
            echo "Warning: Failed to move main bookmark" >&2
        fi
        echo "Work is saved in bookmark '$BOOKMARK_NAME'" >&2
    fi
fi

# ─────────────────────────────────────────────────────────────────
# Cleanup (optional)
# ─────────────────────────────────────────────────────────────────

WS_REMOVED=false
if ! $NO_CLEANUP; then
    # Switch to default workspace first
    cd "$REPO_ROOT"

    # Forget workspace
    if jj workspace forget "$CURRENT_WS" 2>/dev/null; then
        WS_REMOVED=true
    fi

    # Remove directory
    if [[ -d "$WS_DIR" ]]; then
        rm -rf "$WS_DIR"
    fi
fi

# ─────────────────────────────────────────────────────────────────
# Output result
# ─────────────────────────────────────────────────────────────────

if $JSON_OUTPUT; then
    cat <<EOF
{
  "success": true,
  "workspace": {
    "name": "$CURRENT_WS",
    "removed": $WS_REMOVED
  },
  "bookmark": {
    "name": "$BOOKMARK_NAME",
    "created": $BOOKMARK_CREATED,
    "change_id": "$CHANGE_ID"
  },
  "task": {
    "id": "$TASK_ID",
    "closed": $TASK_CLOSED
  },
  "commit": {
    "description": $(echo "$COMMIT_DESC" | jq -Rs .),
    "empty": $COMMIT_EMPTY
  },
  "merged": $MERGED,
  "main": {
    "previous": "$PREV_MAIN",
    "current": "$(if $MERGED; then echo "$CHANGE_ID"; else echo "$PREV_MAIN"; fi)"
  }
}
EOF
else
    echo "✓ Workspace '$CURRENT_WS' work completed"
    if $MERGED; then
        echo "  (merged to main: $PREV_MAIN → $CHANGE_ID)"
    fi
    if $BOOKMARK_CREATED; then
        echo "  (bookmark: $BOOKMARK_NAME)"
    fi
    if $TASK_CLOSED; then
        echo "  (bead task $TASK_ID closed)"
    fi
    if $WS_REMOVED; then
        echo "  (workspace removed)"
    fi
    echo ""
    if $MERGED; then
        echo "Work is now in main. To push to GitHub:"
        echo "  jj log -r main                         # Review what will be pushed"
        echo "  jj git push                            # Push (requires your consent)"
    elif $BOOKMARK_CREATED; then
        echo "To review and merge this work:"
        echo "  jj log -r '$BOOKMARK_NAME'              # Review changes"
        echo "  jj bookmark set main -r '$BOOKMARK_NAME' # Merge to main"
        echo "  jj git push                            # Push (with user consent)"
    fi
    if ! $NO_CLEANUP; then
        echo ""
        echo "Returned to default workspace at $REPO_ROOT"
    fi
fi
